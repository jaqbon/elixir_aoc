# 2019 Day 23

## Setup

```elixir
Mix.install([
  {:kino, "~> 0.6.2"}
])
```

```elixir
input = Kino.Input.textarea("Please paste your input:")
```

```elixir
code =
  input
  |> Kino.Input.read()
  |> String.replace("\n", "")
  |> String.split(",", trim: true)
  |> Enum.with_index(fn e, i -> {i, String.to_integer(e)} end)
  |> Enum.reduce(Map.new(), fn {i, e}, acc -> Map.put(acc, i, e) end)
```

```elixir
defmodule AmpIO do
  use Agent

  def start(initial_list) do
    Agent.start(fn -> initial_list end)
  end

  def stop(pid), do: Agent.stop(pid)

  def push(pid, l) when is_list(l) do
    l
    # maintain order of l in agent
    |> Enum.reverse()
    |> Enum.each(fn x -> Agent.update(pid, fn state -> [x | state] end) end)
  end

  def push(pid, x) do
    Agent.update(pid, fn state -> [x | state] end)
  end

  # push_back treats agent like a queue
  def push_back(pid, l) when is_list(l) do
    new_state = state(pid) ++ l
    Agent.update(pid, fn _state -> new_state end)
  end

  def push_back(pid, x) do
    new_state = Enum.reverse([x | Enum.reverse(state(pid))])
    Agent.update(pid, fn _state -> new_state end)
  end

  def pop(pid) do
    Agent.get_and_update(pid, fn state ->
      case state do
        [] -> {nil, []}
        [x | s] -> {x, s}
      end
    end)
  end

  def peek(pid) do
    Agent.get_and_update(pid, fn state ->
      case state do
        [] -> {nil, []}
        [x | _s] -> {x, state}
      end
    end)
  end

  def set(pid, x) do
    Agent.get_and_update(pid, fn state ->
      case state do
        [] -> {x, [x]}
        [_ | s] -> {x, [x | s]}
      end
    end)
  end

  def state(pid) do
    Agent.get_and_update(pid, fn state -> {state, state} end)
  end

  def empty?(pid), do: length(state(pid)) == 0

  def clear(pid) do
    Agent.update(pid, fn _state -> [] end)
  end
end
```

```elixir
defmodule Intcode do
  def get_opcode(x) do
    case rem(x, 100) do
      1 -> :add
      2 -> :mult
      3 -> :input
      4 -> :output
      5 -> :jmp_true
      6 -> :jmp_false
      7 -> :lt
      8 -> :eq
      9 -> :set_base
      99 -> :halt
    end
  end

  def get_next_mode(modes) do
    mode =
      case rem(modes, 10) do
        0 -> :position
        1 -> :immediate
        2 -> :relative
      end

    {mode, div(modes, 10)}
  end

  def get_modes(opcode, modes), do: get_modes(opcode, modes, [])

  def get_modes(opcode, 0, mode_list) do
    needed_length =
      case opcode do
        :add -> 3
        :mult -> 3
        :input -> 1
        :output -> 1
        :jmp_true -> 2
        :jmp_false -> 2
        :lt -> 3
        :eq -> 3
        :set_base -> 1
        :halt -> 0
      end

    extra = needed_length - length(mode_list)

    if extra > 0 do
      1..extra
      |> Enum.reduce(mode_list, fn _n, ml -> [:position | ml] end)
      |> Enum.reverse()
    else
      Enum.reverse(mode_list)
    end
  end

  def get_modes(opcode, modes, mode_list) do
    {mode, modes} = get_next_mode(modes)
    get_modes(opcode, modes, [mode | mode_list])
  end

  def get_addr(code, addr, mode, r_pid) do
    case mode do
      :position -> code[addr]
      :relative -> code[addr] + AmpIO.peek(r_pid)
      _ -> addr
    end
  end

  def get_value(code, addr, mode, r_pid) do
    case code[get_addr(code, addr, mode, r_pid)] do
      nil -> 0
      x -> x
    end
  end

  def eval_add(code, modes, pc, i_pid, o_pid, r_pid, count) do
    [mode1, mode2, mode3] = modes

    op1 = get_value(code, pc + 1, mode1, r_pid)
    op2 = get_value(code, pc + 2, mode2, r_pid)

    op3 = get_addr(code, pc + 3, mode3, r_pid)

    eval(Map.put(code, op3, op1 + op2), pc + 4, i_pid, o_pid, r_pid, count + 1)
  end

  def eval_mult(code, modes, pc, i_pid, o_pid, r_pid, count) do
    [mode1, mode2, mode3] = modes

    op1 = get_value(code, pc + 1, mode1, r_pid)
    op2 = get_value(code, pc + 2, mode2, r_pid)

    op3 = get_addr(code, pc + 3, mode3, r_pid)

    eval(Map.put(code, op3, op1 * op2), pc + 4, i_pid, o_pid, r_pid, count + 1)
  end

  def eval_input(code, modes, pc, i_pid, o_pid, r_pid, count) do
    case AmpIO.pop(i_pid) do
      nil ->
        {code, pc, count}

      inp ->
        [mode] = modes

        location =
          case mode do
            :position ->
              case code[pc + 1] do
                nil -> 0
                x -> x
              end

            :relative ->
              case code[pc + 1] + AmpIO.peek(r_pid) do
                nil -> 0
                x -> x
              end

            _ ->
              IO.puts("gak")
          end

        eval(Map.put(code, location, inp), pc + 2, i_pid, o_pid, r_pid, count + 1)
    end
  end

  def eval_output(code, modes, pc, i_pid, o_pid, r_pid, count) do
    [mode] = modes

    x = get_value(code, pc + 1, mode, r_pid)

    AmpIO.push(o_pid, x)

    eval(code, pc + 2, i_pid, o_pid, r_pid, count + 1)
  end

  def eval_jmp_true(code, modes, pc, i_pid, o_pid, r_pid, count) do
    [mode1, mode2] = modes

    op1 = get_value(code, pc + 1, mode1, r_pid)
    op2 = get_value(code, pc + 2, mode2, r_pid)

    case op1 do
      0 -> eval(code, pc + 3, i_pid, o_pid, r_pid, count + 1)
      _ -> eval(code, op2, i_pid, o_pid, r_pid, count + 1)
    end
  end

  def eval_jmp_false(code, modes, pc, i_pid, o_pid, r_pid, count) do
    [mode1, mode2] = modes

    op1 = get_value(code, pc + 1, mode1, r_pid)
    op2 = get_value(code, pc + 2, mode2, r_pid)

    case op1 do
      0 -> eval(code, op2, i_pid, o_pid, r_pid, count + 1)
      _ -> eval(code, pc + 3, i_pid, o_pid, r_pid, count + 1)
    end
  end

  def eval_lt(code, modes, pc, i_pid, o_pid, r_pid, count) do
    [mode1, mode2, mode3] = modes

    op1 = get_value(code, pc + 1, mode1, r_pid)
    op2 = get_value(code, pc + 2, mode2, r_pid)

    op3 = get_addr(code, pc + 3, mode3, r_pid)

    result = if op1 < op2, do: 1, else: 0

    eval(Map.put(code, op3, result), pc + 4, i_pid, o_pid, r_pid, count + 1)
  end

  def eval_eq(code, modes, pc, i_pid, o_pid, r_pid, count) do
    [mode1, mode2, mode3] = modes

    op1 = get_value(code, pc + 1, mode1, r_pid)
    op2 = get_value(code, pc + 2, mode2, r_pid)

    op3 = get_addr(code, pc + 3, mode3, r_pid)

    result = if op1 == op2, do: 1, else: 0

    eval(Map.put(code, op3, result), pc + 4, i_pid, o_pid, r_pid, count + 1)
  end

  def eval_set_base(code, modes, pc, i_pid, o_pid, r_pid, count) do
    [mode] = modes

    x = get_value(code, pc + 1, mode, r_pid) + AmpIO.peek(r_pid)

    AmpIO.set(r_pid, x)

    eval(code, pc + 2, i_pid, o_pid, r_pid, count + 1)
  end

  # def eval(_,_,_,_,_,100), do: IO.puts("STOP")

  def eval(code, pc, i_pid, o_pid, r_pid, count) do
    opcode = get_opcode(code[pc])

    modes = get_modes(opcode, div(code[pc], 100))

    case opcode do
      :add ->
        eval_add(code, modes, pc, i_pid, o_pid, r_pid, count)

      :mult ->
        eval_mult(code, modes, pc, i_pid, o_pid, r_pid, count)

      :input ->
        eval_input(code, modes, pc, i_pid, o_pid, r_pid, count)

      :output ->
        eval_output(code, modes, pc, i_pid, o_pid, r_pid, count)

      :jmp_true ->
        eval_jmp_true(code, modes, pc, i_pid, o_pid, r_pid, count)

      :jmp_false ->
        eval_jmp_false(code, modes, pc, i_pid, o_pid, r_pid, count)

      :lt ->
        eval_lt(code, modes, pc, i_pid, o_pid, r_pid, count)

      :eq ->
        eval_eq(code, modes, pc, i_pid, o_pid, r_pid, count)

      :set_base ->
        eval_set_base(code, modes, pc, i_pid, o_pid, r_pid, count)

      :halt ->
        :ok

      _ ->
        IO.puts("1202")
        :choke
    end
  end

  # def resume({_,_,n}, _,_,_) when n > 10, do: :ok

  def resume({code, pc, count}, i_pid, o_pid, r_pid) do
    eval(code, pc, i_pid, o_pid, r_pid, count)
  end

  def run(code) do
    {:ok, i_pid} = AmpIO.start([])
    {:ok, o_pid} = AmpIO.start([])
    {:ok, r_pid} = AmpIO.start([0])

    eval(code, 0, i_pid, o_pid, r_pid, 0)

    output = AmpIO.state(o_pid)

    AmpIO.stop(i_pid)
    AmpIO.stop(o_pid)
    AmpIO.stop(r_pid)

    Enum.reverse(output)
  end
end
```

## Part 1

```elixir
defmodule Part1 do
  def init(code, number) do
    Enum.reduce(0..(number - 1), %{}, fn i, network ->
      {:ok, i_pid} = AmpIO.start([i])
      {:ok, o_pid} = AmpIO.start([])
      {:ok, r_pid} = AmpIO.start([0])

      Map.put(network, i, {{code, 0, 0}, i_pid, o_pid, r_pid})
    end)
  end

  def step_all(network, number) do
    Enum.reduce_while(0..(number - 1), network, fn i, network ->
      if !Map.has_key?(network, i) do
        {:cont, network}
      else
        {dump, i_pid, o_pid, r_pid} = network[i]

        if AmpIO.empty?(i_pid), do: AmpIO.push(i_pid, -1)

        dump = Intcode.resume(dump, i_pid, o_pid, r_pid)

        rtn =
          if AmpIO.empty?(o_pid) do
            :ok
          else
            messages =
              AmpIO.state(o_pid)
              |> Enum.reverse()
              |> Enum.chunk_every(3)

            AmpIO.clear(o_pid)

            Enum.reduce_while(messages, nil, fn [j, x, y], _acc ->
              case j do
                255 ->
                  {:halt, {x, y}}

                _ ->
                  {_, pid, _, _} = network[j]
                  AmpIO.push_back(pid, [x, y])
                  {:cont, :ok}
              end
            end)
          end

        case rtn do
          # didn't find 255 so continue reduction
          :ok ->
            case dump do
              # this Intcode computer has stopped
              :ok ->
                {:cont, Map.delete(network, i)}

              # return saved state of Intcode computer
              _ ->
                {:cont, Map.put(network, i, {dump, i_pid, o_pid, r_pid})}
            end

          # found 255
          _ ->
            {:halt, rtn}
        end
      end
    end)
  end

  def run_network(network, number) do
    case step_all(network, number) do
      {x, y} -> {x, y}
      network -> run_network(network, number)
    end
  end

  def run(code, number) do
    network = init(code, number)

    run_network(network, number)
  end
end
```

```elixir
Part1.run(code, 50)
```

## Part 2

```elixir
defmodule Part2 do
  def init(code, number) do
    network =
      Enum.reduce(0..(number - 1), %{}, fn i, network ->
        {:ok, i_pid} = AmpIO.start([i, -1])
        {:ok, o_pid} = AmpIO.start([])
        {:ok, r_pid} = AmpIO.start([0])

        Map.put(network, i, {{code, 0, 0}, i_pid, o_pid, r_pid})
      end)

    {:ok, nat} = AmpIO.start([])

    {network, nat}
  end

  def step_all(network, number, nat) do
    {num_no_in, num_no_out, network} =
      Enum.reduce(0..(number - 1), {0, 0, network}, fn i, {num_no_in, num_no_out, network} ->
        if !Map.has_key?(network, i) do
          {num_no_in, num_no_out, network}
        else
          {dump, i_pid, o_pid, r_pid} = network[i]

          num_no_in =
            if AmpIO.empty?(i_pid) do
              AmpIO.push(i_pid, -1)
              num_no_in + 1
            else
              num_no_in
            end

          dump = Intcode.resume(dump, i_pid, o_pid, r_pid)

          num_no_out =
            if AmpIO.empty?(o_pid) do
              num_no_out + 1
            else
              messages =
                AmpIO.state(o_pid)
                |> Enum.reverse()
                |> Enum.chunk_every(3)

              AmpIO.clear(o_pid)

              Enum.each(messages, fn [j, x, y] ->
                case j do
                  255 ->
                    AmpIO.clear(nat)
                    AmpIO.push(nat, [x, y])

                  _ ->
                    {_, pid, _, _} = network[j]
                    AmpIO.push_back(pid, [x, y])
                end
              end)

              num_no_out
            end

          network =
            case dump do
              # this Intcode computer has stopped
              :ok ->
                Map.delete(network, i)

              _ ->
                # have returned from Intcode.resume so waiting for input
                # save updated state of Intcode computer
                Map.put(network, i, {dump, i_pid, o_pid, r_pid})
            end

          {num_no_in, num_no_out, network}
        end
      end)

    if num_no_in == map_size(network) and num_no_out == map_size(network) do
      {_, pid, _, _} = network[0]
      [x, y | _] = AmpIO.state(nat)
      IO.inspect([x, y])
      AmpIO.push_back(pid, [x, y])
    end

    network
  end

  def run_network(network, number, nat) do
    network = step_all(network, number, nat)

    case AmpIO.state(nat) do
      [_, y, _, y | _] -> y
      _ -> run_network(network, number, nat)
    end
  end

  def run(code, number) do
    {network, nat} = init(code, number)

    run_network(network, number, nat)

    IO.puts("wtf")
  end
end
```

```elixir
Part2.run(code, 50)
```
